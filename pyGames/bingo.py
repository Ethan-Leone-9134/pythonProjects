"""
File Name   :  bingo3.py
Author      :  Ethan Leone
Date        :  03/11/2024
Description :  This script generates a sample bingo board and dabs the positions as given

Usage:
- Ensure that the required libraries are installed by running 'pip install matplotlib numpy'.
- Update any custom modules.
- Run the script to perform the desired tasks.
"""


#%%%#   Import  Libraries   #%%%#
import matplotlib.pyplot as plt
from matplotlib.text import Text
from matplotlib.animation import FuncAnimation
from itertools import permutations
import numpy as np
import random
import time 
import math


#%%%#   Define  Classes   #%%%#


class crossText(Text):
    def __init__(self, currX, currY, text, fontsize=12, color='black', **kwargs):
            super().__init__(currX, currY, text, fontsize=fontsize, color=color, **kwargs)
            self.posVec = [currX,currY,currX,currY]
            self.set_position((currX, currY))  # Set initial position
            self.set_fontsize(fontsize)  # Set initial fontsize
            self.set_color(color)  # Set initial color
            

    def set_position(self, position):
        self.set_x(position[0])
        self.set_y(position[1])
        
        plt.show()
        if (abs(self.posVec[2]-position[0])+abs(self.posVec[3]-position[1]) > 0.0005):
            plt.pause(0.1)
        self.posVec[0:2] = position

    def set_desired(self, position):
        self.posVec[2:4] = position

    def set_fontsize(self, fontsize):
        super().set_fontsize(fontsize)

    def set_color(self, color):
        super().set_color(color)

    def move(self):
        xSpeed = 0.2
        ySpeed = 0.2
        # Move x
        if self.posVec[0] > self.posVec[2]:
            self.posVec[0] -= xSpeed
        elif self.posVec[0] < self.posVec[2]:
            self.posVec[0] += xSpeed
        else:
            self.posVec[0] = self.posVec[2]

        # Move y
        if self.posVec[1] > self.posVec[3]:
            self.posVec[1] -= ySpeed
        elif self.posVec[1] < self.posVec[3]:
            self.posVec[1] += ySpeed
        else:
            self.posVec[1] = self.posVec[3]

        self.posVec = [round(val, 5) for val in self.posVec]
        # Move cross hair
        self.set_position((self.posVec[0],self.posVec[1]))

    def isFar(self):
        return (abs(self.posVec[0]-self.posVec[2])+abs(self.posVec[1]-self.posVec[3]) > 0.005)


#%%%#   Define  Graphical  Functions   #%%%#


def box(wid, axis=1, star=0):
    if axis:
        return [star, star+wid, star+wid, star, star]
    else:
        return [star, star, star+wid, star+wid, star]

def grid(wid, scale, axis=1, star=0):
    outer = []
    for n in range(scale):
        if (axis):
            wid2 = wid
        else: 
            wid2 = wid*(n+1)

        outer += box(wid2, axis, star)

    return outer

def genFig():
    """
    Function genFig generates the figure window
    Inputs:
        none
    Outputs:
        ax (fig)     : The figure window generated by the function
    """

    fig, ax = plt.subplots(figsize=(4,6))   # Initialize size
    # line, = ax.plot([], [], lw=2)
    ax.set_title("Bingo Board")             # Set title
    ax.axis('equal')                        # Set equal axis WIDTH

    ax.set_xticks(range(0,WIDTH*5+1))        # Set x ticks
    ax.set_yticks(range(-HEIGHT*5+1,0))        # Set y ticks

    ax.set_xlim(-0.01,WIDTH *5 + 0.01)        # Set x limit
    ax.set_ylim(-HEIGHT*5-0.02, + 0.02)        # Set y limit

    ax.set_xticklabels([])      # Hide x labels
    ax.set_yticklabels([])      # Hide y labels

    plt.ion()
    plt.grid(which='major', axis='both', linestyle='-',linewidth=1)

    return ax


#%%%#   Define  Temp  Functions   #%%%#


def randVec(min:int,max:int,len:int,count:int=1) -> list:
    """
    Function randVec creates a vector of random points without repeating unless count is specified
    Inputs:
        min (int)      : Minimum of vector range
        max (int)      : Maximum of vector range
        len (int)      : Number of points in simple vector
        count (int)    : Number of repeatitions of vector
    Outputs:
        vect (list)    : Random integer vector
    """

    vect = []                               # Initialize list variable
    for bNum in range(count):               # For each repeatition
        currLine = list(range(min, max+1))      # Generate linear list
        random.shuffle(currLine)                # Shuffle data points in new addition
        vect += currLine[0:len]                 # Add to list
    return vect                             # Output list


#%%%#   Define  Scanning  Functions   #%%%#


def getIndex(aray: list, value: int) -> list:
    """
    Function searches a list for a specific value
    Inputs:
        aray  (1-D List)    : List to be searched through
        value (int)         : Value to be detected
    Outputs:
        indexes (list)      : List of indexes where a match was found
    """

    # Found index list
    indexes = [index for index, element in enumerate(aray) if element == value]
    # Output vector
    return indexes


def readCalls(timeOriginal:float, called:list):
    # Find calls
    ranNum = 0
    if len(called) == 73:
        called += "end"
    else:
        if (time.time() - timeOriginal) > 15*((len(called)-1)):
            ranNum = random.randint(1,75)
            while ranNum in called:
                ranNum = random.randint(1,75)
            called += [(ranNum)]
            print(f"Ball call: {ranNum}")

    return called, ranNum


def findTargets(board, currBall):

    targets = []
    for n in range(WIDTH):
        col = math.floor((currBall-1)/15)+(5*n)   # column Number
        if currBall in board[col]:                # If there is a match
            spotz = getIndex(board[col],currBall)     # Find all indexes
            if (n+1) % 2 == 0:
                spotz.reverse()
            for spot in (spotz):                    # Repeat for each found position
                targets += [[col, spot, currBall]]

    # print(targets)
    return targets


def optRoute(targets, currPos):
    permz = (list(permutations(targets, len(targets))))
    distz = []          # Average distances
    for thisPerm in (permz):
        perm = [[currPos[0]] + [(float(currPos[1])-HEIGHT*5)] + [0]] + list(thisPerm)
        dist = []
        for pointNum in range(len(perm)-1):
            distSq = ((perm[pointNum][0] - perm[pointNum+1][0])**2 + (perm[pointNum][1] - perm[pointNum+1][1])**2 )
            dist.append(math.sqrt( distSq ) )
            # dist += abs(perm[pointNum][0] - perm[pointNum+1][0]) + abs(perm[pointNum][1] - perm[pointNum+1][1])
        
        try:
            distz.append(sum(dist) / len(dist))
        except ZeroDivisionError:
            distz.append(0)  # Handle case where dist is an empty list
        # print(f"The list {dist} has sum {sum(dist)} and len {len(dist)}")

    minIndex = distz.index(min(distz))
    # print("")
    # # print(f"Distances vector {distz}")
    # print(f"For a minimum of {min(distz)}, Index {minIndex} gives the vector {[currPos[0:2] + [0]] + list(permz[minIndex])}")
    # print("")
    targets = list(permz[minIndex])
    print(targets)
    return targets

#%%%# 





#%%%#   Start  Main  Code   #%%%#

# Set size
WIDTH = 2
HEIGHT = 3

# Generate boards
board = []
for n in range(WIDTH*5):
    board += [randVec(1 + HEIGHT*5*(n % 5), HEIGHT*5 + HEIGHT*5*(n % 5), 5, HEIGHT)]
print(board)

# Graph lines
xpoints = np.array(grid(5,3,1,0) + grid(10,3,1,5))
ypoints = np.array(grid(5,HEIGHT,0,-HEIGHT*5) + grid(5,HEIGHT,0,-HEIGHT*5))
ax = genFig()
# line, = ax.plot([], [], lw=2)
ax.plot(xpoints, ypoints)       # Make plot
plt.pause(0.5)

# Place numbers
for c in range(WIDTH*5):
    for r in range(HEIGHT*5):
        ax.text(c+0.2, -r-0.8, board[c][r], fontsize=13, color='blue' )
    plt.show()
    plt.pause(.1)

# Generate crosshair 
cHair = ax.add_artist(crossText(2,-1,"+", fontsize=28, color='blue'))
tOrigin = time.time()

# Call numbers
called = [0]                  # List of called numbers
tars = []
while "end" not in called:                  # While game is active
    # Detect routes
    [called, currBall] = readCalls(tOrigin, called) # Detect ball number inputs
    if currBall != 0:                       # If there is an actual ball to detect
        tars += findTargets(board, currBall)    # Find all targets to hit
        tars = optRoute(tars, cHair.posVec)     # Optimize the target list
        for targ in tars:                       # Set target rings
            ax.text(targ[0],-targ[1]+0.25-1, "⬤", fontsize=20, color='red',alpha=0.05)

    # Set desired position
    if tars != []:
        cHair.set_desired([tars[0][0],-1-tars[0][1]] )# Set the desired position
        cHair.set_color("blue")
    else:
        cHair.set_desired([(1*5-1)/2,-1])       # Move to reset
        cHair.set_color("green")

    # Change position
    if tars != []:                  # If there are targets to hit
        if cHair.isFar():              # If the marker is not over a target
            cHair.move()                            # Move the marker
        else:
            plt.pause(0.5)                          # Pause for the dabbing
            ax.text(cHair.posVec[0],cHair.posVec[1]+0.25, "⬤", fontsize=20, color='green',alpha=0.25)
            plt.show()                              # Show the plot
            print(f"Ball call {tars[0][2]} pressed at time: {round(time.time() - tOrigin,2)} / {15*(len(called)-1)} [s]")
            tars.remove(tars[0])
    cHair.move()
    time.sleep(0.05)
    

plt.show(block=True)
#%%%#   End  of  Script  File   #%%%#
